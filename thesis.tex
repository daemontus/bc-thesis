\documentclass[12pt,oneside,draft]{fithesis2}
\usepackage[english]{babel}       % Multilingual support
\usepackage[utf8]{inputenc}       % UTF-8 encoding
\usepackage[T1]{fontenc}          % T1 font encoding
\usepackage[                      % A sans serif font that blends well with Palatino
  scaled=0.86
]{berasans}
\usepackage[                      % A tt font if you do not like LM's tt
  scaled=1.03
]{inconsolata}
\usepackage[                      % Clickable links
  plainpages = false,               % We have multiple page numberings
  pdfpagelabels                     % Generate pdf page labels
]{hyperref}
\usepackage{blindtext}            % Lorem ipsum generator

 % Algorithms
\usepackage{algorithm}
%\usepackage[noend]{algpseudocode}
\usepackage{algpseudocode}

\thesislang{en}                   % The language of the thesis
\thesistitle{Parameter Synthesis from Hypotheses Formulable in CTL Logic}       % The title of the thesis
\thesissubtitle{Bachelor Thesis}  % The type of the thesis
\thesisstudent{Samuel Pastva}          % Your name
\thesiswoman{false}                % Your gender
\thesisfaculty{fi}                % Your faculty
\thesisyear{Spring \the\year}     % The academic term of your thesis defense
\thesisadvisor{John Foo, Ph.D.}   % Your advisor


% Macros for definitions
% Assumptions
\newcommand{\as}[1][]{\ensuremath{\mathcal{A}_{#1}}}
\newcommand{\asemt}{\as[\perp]}
\newcommand{\ASphi}{\ensuremath{AS_{\mathcal K}^\phi}}

% Algorithm
\newcommand{\method}[1]{\textnormal{\textsc{#1}}}

%True, false
\newcommand{\true}{\ensuremath{\texttt{tt}}}
\newcommand{\false}{\ensuremath{\texttt{ff}}}

% Kripke
\newcommand{\ks}[1][]{\ensuremath{\mathcal{K}_{#1}}}
\newcommand{\fullks}{\ensuremath{ \ks = (id, f, \params, S, I, \trans{p}, L) }}
\newcommand{\trans}[1]{\stackrel{#1}{\rightarrow}}
\newcommand{\params}{\mathcal{P}}

%Temporal
\newcommand{\eu}[2]{\ensuremath{\mbox{E} #1 \mbox{U} #2 }}
\newcommand{\au}[2]{\ensuremath{\mbox{A} #1 \mbox{U} #2 }}
\newcommand{\ex}[1]{\ensuremath{\mbox{EX} #1}}
\newcommand{\ax}[1]{\ensuremath{\mbox{AX} #1}}
\newcommand{\ef}[1]{\ensuremath{\mbox{EF} #1}}
\newcommand{\af}[1]{\ensuremath{\mbox{AF} #1}}
\newcommand{\eg}[1]{\ensuremath{\mbox{EG} #1}}
\newcommand{\ag}[1]{\ensuremath{\mbox{AG} #1}}

\begin{document}
  \FrontMatter                    % The front matter
    \ThesisTitlePage                % The title page
    \begin{ThesisDeclaration}       % The declaration
      \DeclarationText
      \AdvisorName
    \end{ThesisDeclaration}
    \begin{ThesisThanks}            % The acknowledgements (optional)
      I would like to thank my supervisor\,\dots
    \end{ThesisThanks}
    \begin{ThesisAbstract}          % The abstract
      The aim of the bachelor work is to provide\,\dots
    \end{ThesisAbstract}
    \begin{ThesisKeyWords}          % The keywords
      keyword1, keyword2\,\dots
    \end{ThesisKeyWords}
    \tableofcontents                % The table of contents
%   \listoftables                   % The list of tables (optional)
%   \listoffigures                  % The list of figures (optional)
  
  \MainMatter                     % The main matter
    \chapter{Introduction}          % Chapters
	Lorem Ipsum \cite{testCite}
    \chapter{Algorithm}
    
    	In this chapter, we describe the distributed algorithm that computes the assumption function $\as$. 
    	
    	\section{Distributed Environment}
    	
		In this section, we briefly describe the distributed environment assumed by our algorithm, in order to prevent any possible confusion. 
		
		We assume a distributed environment with fixed number of reliable processes connected by reliable, order-preserving channels (The order preservation can be relaxed to some extent). We also assume that each process has a fixed identifier and the set of all process identifiers equals the result set of the partition function. 
		
		Several parts of the algorithm do not have explicit termination (they terminate by reaching deadlock - no messages are exchanged between processes). In such cases, suitable termination detection algorithm is employed to detect this deadlock and terminate computation properly. Our implementation uses Safra's algorithm [CITATION] for this purpose, but the related code has been skipped for easier readability.
    	
		\section{Algorithm outline}
		
			The main idea of the algorithm is described in REFERENCE and resembles other CTL model checking algorithms.
			
			\begin{algorithmic}[1]
				\Procedure{CheckCTL}{$ \phi, \fullks $}
					\State $ \as \gets \{ (p, s, \alpha, \true) \mid  p \in \params \wedge \alpha \in L(s) \}$ 
					\ForAll { $ i < | \phi | $ }					
						\ForAll { $ \psi $ \textbf{in} $ cl(\phi) $ \textbf{where} $ | \psi | = i $ }
							\State $ \as \gets \Call{CheckFormula}{\psi, \ks, \as } $
						\EndFor
					\EndFor
				\EndProcedure			
			\end{algorithmic} 
			
			The algorithm starts by initializing the assumption function using the labeling function defined in kripke fragment. After that, it traverses the structure of formula, starting from smallest formulas and uses computed results to process more complex formulas. Function \method{CheckFormula} computes all states and colors where formula $\psi$ holds and returns assumption function updated accordingly. This is done using the local information contained in given kripke fragment, assumptions previously computed for smaller formulas and also by communicating with other processes. Note that only assumptions relevant for particular process are computed and returned (each process has information only about it's own state space).
    	
    	\section{Common operations}
    		
    		In this section, we define functions used to simplify the algorithm description. Let us fix a formula $\phi$ and a parametrised kripke fragment $\fullks$ as input of the algorithm.
			
			Intuitively, function $validStates : cl(\phi) \times \ASphi \rightarrow S \times 2^\mathcal{P} $ computes a set of states and parameters where truth of given formula is assumed. It is also responsible for handling of boolean operators, since these can be computed without any inter-process communication. 
			
			\begin{center}
				$validStates(\phi_1 \wedge \phi_2, \as) = \{ (s, p) \mid \as(s, p, \phi_2) = \true \wedge \as(s, p, \phi_2) = \true \} $
			\end{center}
			
			\begin{center}
				$validStates(\phi_1 \vee \phi_2, \as) = \{ (s, p) \mid \as(s, p, \phi_2) = \true \vee \as(s, p, \phi_2) = \true \} $
			\end{center}
			
			\begin{center}
				$validStates(\neg\phi, \as) = \{ (s, p) \mid \as(s, p, \phi_2) = \false \} $
			\end{center}
			
			\begin{center}
				$validStates(\phi, \as) = \{ (s, p) \mid \as(s, p, \phi) = \true \} $
			\end{center}
			
			Function $predecessors : S \rightarrow S \times 2^\mathcal{P} $ computes set of direct predecessors of given node including the color sets labeling the appropriate transitions.
			
			\begin{center}
				$predecessors(to) = \{ (from, P) \mid P = \{ p \mid from \trans{p} to \} \} $
			\end{center}
			
			Symmetrically, function $successors : S \rightarrow S \times 2^\mathcal{P} $ computes set of direct successors of given node including the color sets labeling the appropriate transitions.

			\begin{center}
				$predecessors(from) = \{ (to, P) \mid P = \{ p \mid from \trans{p} to \} \} $
			\end{center}		
    
   		\section{Exist Next Operator}
			\begin{algorithmic}[1]
			\State $ \textbf{Process variables:} $
			\State $ \ks = (id, f, \mathcal{P}, S, I, \trans{p}, L) $ \Comment{Kripke fragment}
			\State $ \phi = \ex{\phi_1}  $ \Comment{CTL formula}
			\State $ \as $ \Comment{Initial assumption function}
			\Procedure{Init}{}
				\ForAll {$state$ \textbf{in} $ validStates(\phi_1, \as, \ks) $}
					\ForAll { $ (pred, tranCol) $ \textbf{in} $ predecessors(state, \ks) $ }
						\State $ \Call{Send}{f(state), (pred, \mathcal{P} \cup tranCol)} $
					\EndFor
				\EndFor
			\EndProcedure
			\Procedure{Receive}{$colSet, to$}
				\State $ \as \gets \as \cup \{ (p, to, \phi) \mid p \in colSet \}$
			\EndProcedure
			\end{algorithmic}	
			
    	\section{Exist Until Operator}
			\begin{algorithmic}[1]
			\State $ \textbf{Process variables:} $
			\State $ \ks = (id, f, \mathcal{P}, S, I, \trans{p}, L) $ \Comment{Kripke fragment}
			\State $ \phi = \eu{\phi_1}{\phi_2}  $ \Comment{CTL formula}
			\State $ \as $ \Comment{Initial assumption function}
			\Procedure{Init}{}
				\ForAll {$state$ \textbf{in} $ validStates(\phi_2, \as, \ks) $}
					\State $ \as \gets \as \cup (\mathcal{P}, state, \phi) $
					\ForAll { $ (pred, tranCol) $ \textbf{in} $ predecessors(state, \ks) $ }
						\State $ \Call{Send}{f(state), (state, pred, \mathcal{P} \cup tranCol)} $
					\EndFor
				\EndFor
			\EndProcedure
			\Procedure{Receive}{$colSet, from, to$}
				\State $ colSet \gets colSet \cap valid(\phi_1, to, \as)$
				\If{$ colSet \neq \emptyset $ \textbf{and} $ colSet \setminus valid(\phi, to, \as) \neq \emptyset $}
					\State $ \as \gets \as \cup (colSat, to, \phi)$
					\ForAll {$(pred, tranCol) $ \textbf{in} $ predecessors(to, \ks) $ }
						\State $ \Call{Send}{f(pred), (to, pred, colSat \cup tranCol)} $
					\EndFor
				\EndIf
			\EndProcedure
			\end{algorithmic}	
			
			
	    \section{All Until Operator}
			\begin{algorithmic}[1]
			\State $ \textbf{Process variables:} $
			\State $ \ks = (id, f, \mathcal{P}, S, I, \trans{p}, L) $ \Comment{Kripke fragment}
			\State $ \phi = \au{\phi_1}{\phi_2}  $ \Comment{CTL formula}
			\State $ S = \emptyset $
			\State $ \as $ \Comment{Initial assumption function}
			\Procedure{Init}{}
				\ForAll {$state$ \textbf{in} $ validStates(\phi_2, \ks) $}
					\ForAll { $ (pred, tranCol) $ \textbf{in} $ predecessors(state, \ks) $ }
						\State $ \Call{Send}{f(state), (state, pred, \mathcal{P} \cup tranCol)} $
					\EndFor
				\EndFor
			\EndProcedure
			\Procedure{Receive}{$colSet, from, to$}	
				\State $ S \gets S \cup (to, from, colSet) $
				\State $ colSet \gets colSet \cap valid(\phi_1, to, \ks)$
				\If{$ colSet \neq \emptyset $ \textbf{and} $ colSet \setminus valid(\phi, to, \ks) \neq \emptyset $}
					\State $ \as \gets \as \cup (colSat, to, \phi)$
					\ForAll {$(pred, tranCol) $ \textbf{in} $ predecessors(to, \ks) $ }
						\State $ \Call{Send}{f(pred), (to, pred, colSat \cup tranCol)} $
					\EndFor
				\EndIf
			\EndProcedure
			\end{algorithmic}	
			
			
    \appendix
    \chapter{First appendix}        % Appendices
    \Blindtext
    \chapter{Another appendix}
    \Blindtext

    \bibliographystyle{ieeetr}  
	\bibliography{bibliography}
    % Bibliography goes here
    % Index goes here (optional)
\end{document}
