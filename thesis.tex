\documentclass[12pt,oneside,draft]{fithesis2}
\usepackage[english]{babel}       % Multilingual support
\usepackage[utf8]{inputenc}       % UTF-8 encoding
\usepackage[T1]{fontenc}          % T1 font encoding
\usepackage[                      % A sans serif font that blends well with Palatino
  scaled=0.86
]{berasans}
\usepackage[                      % A tt font if you do not like LM's tt
  scaled=1.03
]{inconsolata}
\usepackage[                      % Clickable links
  plainpages = false,               % We have multiple page numberings
  pdfpagelabels                     % Generate pdf page labels
]{hyperref}
\usepackage{blindtext}            % Lorem ipsum generator

 % Algorithms
\usepackage{algorithm}
%\usepackage[noend]{algpseudocode}
\usepackage{algpseudocode}

\thesislang{en}                   % The language of the thesis
\thesistitle{Parameter Synthesis from Hypotheses Formulable in CTL Logic}       % The title of the thesis
\thesissubtitle{Bachelor Thesis}  % The type of the thesis
\thesisstudent{Samuel Pastva}          % Your name
\thesiswoman{false}                % Your gender
\thesisfaculty{fi}                % Your faculty
\thesisyear{Spring \the\year}     % The academic term of your thesis defense
\thesisadvisor{John Foo, Ph.D.}   % Your advisor


% Macros for definitions
% Assumptions
\newcommand{\as}[1][]{\ensuremath{\mathcal{A}_{#1}}}
\newcommand{\asemt}{\as[\perp]}
\newcommand{\ASphi}{\ensuremath{AS_{\mathcal K}^\phi}}

% Algorithm
\newcommand{\method}[1]{\textnormal{\textsc{#1}}}

%True, false
\newcommand{\true}{\ensuremath{\texttt{tt}}}
\newcommand{\false}{\ensuremath{\texttt{ff}}}

% Kripke
\newcommand{\ks}[1][]{\ensuremath{\mathcal{K}_{#1}}}
\newcommand{\kf}[2]{\ensuremath{\mathcal{F}^{#2}_{#1}}}
\newcommand{\fullKs}{\ensuremath{ \ks = (\params, S, S_0, \trans{}, L) }}
\newcommand{\fullKf}[2]{\ensuremath{ \kf{#1}{#2} = (f, \params, S_{#1}, I_{i}, \trans{}_{#1}, L_{#1}) }}
\newcommand{\trans}[1]{\stackrel{#1}{\rightarrow}}
\newcommand{\params}{\mathcal{P}}

%Temporal
\newcommand{\eu}[2]{\ensuremath{\mbox{E} #1 \mbox{U} #2 }}
\newcommand{\au}[2]{\ensuremath{\mbox{A} #1 \mbox{U} #2 }}
\newcommand{\ex}[1]{\ensuremath{\mbox{EX} #1}}
\newcommand{\ax}[1]{\ensuremath{\mbox{AX} #1}}
\newcommand{\ef}[1]{\ensuremath{\mbox{EF} #1}}
\newcommand{\af}[1]{\ensuremath{\mbox{AF} #1}}
\newcommand{\eg}[1]{\ensuremath{\mbox{EG} #1}}
\newcommand{\ag}[1]{\ensuremath{\mbox{AG} #1}}

\begin{document}
  \FrontMatter                    % The front matter
    \ThesisTitlePage                % The title page
    \begin{ThesisDeclaration}       % The declaration
      \DeclarationText
      \AdvisorName
    \end{ThesisDeclaration}
    \begin{ThesisThanks}            % The acknowledgements (optional)
      I would like to thank my supervisor\,\dots
    \end{ThesisThanks}
    \begin{ThesisAbstract}          % The abstract
      The aim of the bachelor work is to provide\,\dots
    \end{ThesisAbstract}
    \begin{ThesisKeyWords}          % The keywords
      keyword1, keyword2\,\dots
    \end{ThesisKeyWords}
    \tableofcontents                % The table of contents
%   \listoftables                   % The list of tables (optional)
%   \listoffigures                  % The list of figures (optional)
  
  \MainMatter                     % The main matter
    \chapter{Introduction}          % Chapters
	Lorem Ipsum \cite{testCite}

	\chapter{Terms and Definitions}
		
		\section{Kripke Structure}
	
			As an input of our algorithm, we expect a parametrized Kripke Structure as defined in [CITE]. Parametrized Kripke Structure is a tuple $\fullKs$ where
			
			\begin{itemize}
				\item $\params$ is a finite set of parameters (all possible parameter valuations)
				\item $S$ is a finite set of states
				\item $S_0 \subseteq S$ is a set of initial states
				\item $\trans{} \subseteq S \times \params \times S$ is a transition relation labeled by parameter valuations 
				\item $L: S \rightarrow 2^{AP} $ is a labeling function from states to sets of atomic propositions which are true in such states
			\end{itemize} 		
			
			We write $ s \trans{p} s' $ when $ (s, p, s') \in \trans{} $. We also write $ s \trans{} s'$ when $\exists p \in \params. (s, p, s') \in \trans{} $. Note that fixing a valuation $p \in \params$ reduces the Parametrized Kripke Structure $\ks$ to concrete, non-parametrized Kripke Structure $\ks(p) = (S, S_0, \trans{p}, L)$.
						
		\section{CTL Logic}
		
			In order to correctly express various hypotheses in systems biology, the idea of branching time is need. Examples of such hypotheses are given in section [Case Study]. Therefore, this work uses the Computation Tree Logic(CTL) as means of hypotheses formulation. 

			CTL syntax is defined inductively upon finite set of atomic propositions:
			
			\begin{equation}
				\varphi ::= 
					true \mid
					false \mid
					Q \mid 
					\neg \varphi_1 \mid 
					\varphi_1 \wedge \varphi_2 \mid
					\ex{\varphi_1} \mid
					\eu{\varphi_1}{\varphi_2} \mid
					\au{\varphi_1}{\varphi_2}			
			\end{equation}
			
			Sometimes, we will use parentheses to make bigger formulas easily readable, but they will in no way be used to modify the meaning of formula or priority of operators.
			
			Note	 that there are also other temporal operators in standard CTL definition. We do not implement those directly in our algorithm. However, we use following equations to transform any general CTL formula prior to computation, so that it only uses operators supported in our algorithm. This way we can achieve a concise algorithm and also support whole CTL logic.
			
			\begin{itemize}
				\item $ \ax{\varphi} = \neg \ex{ \neg \varphi } $
				\item $ \ef{\varphi} = \eu{(true)}{\varphi} $
				\item $ \eg{\varphi} = \neg \au{(true)}{\neg \varphi} $
				\item $ \af{\varphi} = \au{(true)}{\varphi} $
				\item $ \ag{\varphi} = \neg \eu{(true)}{\neg \varphi}$
			\end{itemize}
			
			Note that all of these transformations also preserve number of temporal operators in a formula. 
			
			Other boolean operators like implication or equivalence can also be derived using similar transformations. 			
			
			Let $\varphi$ be a CTL formula. We write $cl(\varphi)$ to denote the set of all sub-formulas of $\varphi$ and $tcl(\varphi)$ to denote the set of all temporal sub-formulas of $\varphi$. By $|\varphi|$ we denote the size of formula $\varphi$.
			
			We assume standard CTL semantics over non-parametrized Kripke structures as defined in [cite].

		\section{Parameter Synthesis Problem}
			
			Parameter synthesis problem is defined in following way. Suppose we are given a parametrised Kripke structure $\fullKs$ and a CTL formula $\varphi$. For each state $s \in S$ let $ P_s = \{ p \in \params \mid s \models_{\ks(p)} \varphi \} $,where $s \models_{\ks(p)} \varphi$ denotes, that $\varphi$ is satisfied in the state $s$ of $\ks(p)$. The parameter synthesis problem requires to compute the function $\mathcal{M}_{\varphi}^{\ks} : S \rightarrow 2^\params $ such that $\mathcal{M}_{\varphi}^{\ks}(s) = P_s$. Often we are especially interested in computing the set of all parameters for which the property holds in some initial states $\cap_{s\in S_0}\mathcal{M}_\varphi^{\mathcal K}(s)$. We will sometimes omit the $\varphi$ and $\ks$ when they are clear from the context.	
				
		\section{CTL logic and model approximation}
		
			In model checking, some modeling approaches suffer from over or under approximation. We say that model is over-approximated when all feasible transitions are contained in the model, but it can also contain transitions that are not feasible in the situation the model is describing. Symmetrically, we say that model is under-approximated when all transitions in the model are feasible in the modeled situation, but not all feasible transitions has to be contained in the model. 
			
			It is important to discuss this relationship between CTL and approximated models, because it is much more complicated compared to linear-time logic since CTL allows for universal and existential quantification mixing.
			
			We say that CTL formula is \emph{universal} or that it belongs to ACTL when it only contains universal temporal operators and no negation. Symmetrically, we say that CTL formula is \emph{existential} or that it belongs to ECTL when it only contains existential temporal operators and no negation.
			
			Observe that the truth of ACTL properties is preserved in over-approximated models. In other words, if an ACTL property holds in an over-approximated model, it must also hold in the original model. However, their falsity cannot be guaranteed, because the false transitions may introduce paths that falsify the property in states where it would be normally true. Similarly, the falsity of ECTL properties in over-approximated models is preserved but the truth is not. In this case, the existence of false transitions can introduce states where ECTL property holds solely due to these false paths.
			
			Symmetrically, for under-approximated models, the falsity of ACTL and the truth of ECTL is preserved. But due to similar arguments, we can't say anything about their counterparts.
			
			If we allow full CTL, in general, we can't make any assumptions about results obtained from either under- or over-approximated systems. This is caused by mixing of existential and universal quantification which leads to results which may be spurious and incomplete at the same time. Therefore, no conclusions can be made without further investigation and validation of such results.
			
		\section{Kripke Fragments}
		
			Due to the state space explosion, given parametrised Kripke structure can be very large and therefore impossible to fit into memory of one computer. In order to solve parameter synthesis problem for such structures, we have to distribute the state space across several computational nodes. To this end, we introduce the notion of parametrised kripke fragments.
			
			A parametrised Kripke structure $\ks$ can be divided into several parametrised Kripke fragments $\kf{1}{\ks}, \kf{2}{\ks}, \cdots , \kf{N}{\ks}$. Parametrised Kripke fragment over Kripke structure $\fullKs$ is then defined as a tuple $\fullKf{i}{\ks}$ where:
			
			\begin{itemize}
				\item $f : S \rightarrow \{1, \cdots , N \}$ is a partition function from all states to fragment indexes
				\item $\params$ is a finite set of all parameters
				\item $S_{i} = \{ s \in S \mid f(s) = i \vee \exists s'\in S. ((s \trans{} s' \vee s' \trans{} s) \wedge f(s') = i \}$ is a subset of original state space which belongs to this fragment
				\item $I_{i} = \{ s \in S_0 \mid s \in S_{i} \} $ is a set of all fragments initial states
				\item $\trans{}_{i} = \{ (s, p, s') \in \trans{} \mid s \in S_{i} \wedge s' \in S_{i} \}$ is a subset of original transition function reduced to only relevant states
				\item $L_{i} = \{ (s, l) \in L \mid f(s) = i \}$ is a labeling subset of original labeling function relevant to this fragment
			\end{itemize}
						
		
    \chapter{Algorithm}
    
    	In this chapter, we describe the distributed algorithm that computes the assumption function $\as$. 
    	
    	\section{Distributed Environment}
    	
		In this section, we briefly describe the distributed environment assumed by our algorithm, in order to prevent any possible confusion.
		
		We assume a distributed environment with fixed number of reliable processes connected by reliable, order-preserving channels (The order preservation can be relaxed to some extent). We also assume that each process has a fixed identifier and the set of all process identifiers is equal to the result set of the partition function. Each process can communicate directly (using the function \method{Send}) with any other process (assuming it knows other process's identifier) and all messages that can't be processed directly are stored in a queue until they can be processed.
		
		Several parts of the algorithm do not have explicit termination (they terminate by reaching deadlock - no messages are exchanged between processes). In such cases, suitable termination detection algorithm is employed to detect this deadlock and terminate computation properly. Our implementation uses Safra's algorithm [CITATION] for this purpose, but the related code has been skipped for easier readability.
    	
		The algorithm is broken into two main parts. First describes the general outline of algorithm and is similar to classic CTL model checking. Second part describes how each of the supported temporal operators is processed. This part contains more detailed description of inter-process communication and operator specific data structures. To better reflect the distributed nature of the algorithm, description of each temporal operator routine is divided into three parts: Process variables, Initialization and Message handler. First section describes data structures stored in process memory available during whole computation. Initialization section is executed exactly once and no messages can be received until it's finished. Message handler defines what should happen when message is received.  
		
		\section{Algorithm outline}
		
			The main idea of the algorithm is described in REFERENCE and resembles other CTL model checking algorithms.
			
			\begin{algorithmic}[1]
				\Procedure{CheckCTL}{$ \phi, \fullKs $}
					\State $ \as \gets \{ (p, s, \alpha, \true) \mid  p \in \params \wedge \alpha \in L(s) \}$ 
					\ForAll { $ i < | \phi | $ }					
						\ForAll { $ \psi $ \textbf{in} $ cl(\phi) $ \textbf{where} $ | \psi | = i $ }
							\State $ \as \gets \Call{CheckFormula}{\psi, \ks, \as } $
						\EndFor
					\EndFor
				\EndProcedure			
			\end{algorithmic} 
			
			The algorithm starts by initializing the assumption function using the labeling function defined in kripke fragment. After that, it traverses the structure of formula, starting from smallest formulas and uses computed results to process more complex formulas. Function \method{CheckFormula} computes all states and colors where formula $\psi$ holds and returns assumption function updated accordingly. This is done using the local information contained in given kripke fragment, assumptions previously computed for smaller formulas and also by communicating with other processes. Note that only assumptions relevant for particular process are computed and returned (each process has information only about it's own state space).
    	
    	\section{Common operations}
    		
    		In this section, we define functions used to simplify the algorithm description. Let us fix a formula $\phi$ and a parametrised kripke fragment $\fullKs$ as an input of the algorithm.
			
			Intuitively, function $validStates : cl(\phi) \times \ASphi \rightarrow S \times 2^\mathcal{P} $ computes a set of states and parameters where truth of given formula is assumed. It is also responsible for handling of boolean operators, since these can be computed without any inter-process communication. 
			
			\begin{center}
				$validStates(\phi_1 \wedge \phi_2, \as) = \{ (s, p) \mid \as(s, p, \phi_2) = \true \wedge \as(s, p, \phi_2) = \true \} $
			\end{center}
			
			\begin{center}
				$validStates(\phi_1 \vee \phi_2, \as) = \{ (s, p) \mid \as(s, p, \phi_2) = \true \vee \as(s, p, \phi_2) = \true \} $
			\end{center}
			
			\begin{center}
				$validStates(\neg\phi, \as) = \{ (s, p) \mid \as(s, p, \phi) = \false \} $
			\end{center}
			
			\begin{center}
				$validStates(\true, \as) = \{ (s, p) \mid s \in S \wedge p \in \params \} $
			\end{center}

			\begin{center}
				$validStates(\false, \as) = \emptyset $
			\end{center}
						
			\begin{center}
				$validStates(\phi, \as) = \{ (s, p) \mid \as(s, p, \phi) = \true \} $
			\end{center}

			Another useful function is $validColours : cl(\phi) \times S \times \ASphi \rightarrow 2^\mathcal{P}	$ which returns a set of parameters for which given formula is assumed to be true in given state. 
			
			\begin{center}
				$validColours(\phi, state, \as) = \{ p | (state, p) \in validStates \}$
			\end{center}
			
			We also write $successors_{\ks} : S \rightarrow S \times 2^\mathcal{P} $ which computes set of direct successors of given node including the color sets labeling the appropriate transitions.

			\begin{center}
				$predecessors(from) = \{ (to, P) \mid P = \{ p \mid from \trans{p} to \} \} $
			\end{center}		
			
			Symmetrically, function $predecessors : S \rightarrow S \times 2^\mathcal{P} $ computes set of direct predecessors of given node including the color sets labeling the appropriate transitions.
			
			\begin{center}
				$predecessors(to) = \{ (from, P) \mid P = \{ p \mid from \trans{p} to \} \} $
			\end{center}
			We also define function $update: \ASphi \times S \times 2^{\params} \times tcl(\phi) \rightarrow \ASphi $ which takes current assumptions, a state, set of parameters and a formula and returns assumptions updated so that for all parameters of the given set, formula holds in given state.
			
			\begin{algorithmic}
				\State $ update(\as, state, colours, \phi): $
				\ForAll { $ p \in colours $}
					\State Set $ \as(state, p, \phi) = \true $
				\EndFor 
			\end{algorithmic}
			
		\section{Temporal Operators}
    
    		In this section, we describe how the \method{CheckFormula} is implemented for each of the temporal operators. Note that all of the following algorithms has implicit termination and therefore needs a proper termination detection algorithm to correctly terminate.
    		
	   		\subsection{Exist Next Operator}
   			   			
				\begin{algorithmic}[1]
				\State $ \textbf{Process variables:} $
				\State $ \ks = (id, f, \mathcal{P}, S, I, \trans{p}, L) $ \Comment{Kripke fragment}
				\State $ \phi = \ex{\phi_1}  $ \Comment{CTL formula}
				\State $ \as $ \Comment{Initial assumption function}
				\Procedure{Init}{}
					\ForAll {$(state, colSet)$ \textbf{in} $ validStates(\phi_1, \as) $}
						\ForAll { $ (pred, tranCol) $ \textbf{in} $ predecessors(state) $ }
							\State $ \Call{Send}{f(state), (pred, colSet \cap tranCol)} $
						\EndFor
					\EndFor
				\EndProcedure
				\Procedure{Receive}{$colSet, to$}
					\State $ \as \gets update(\as, to, colSet, \phi)$
				\EndProcedure
				\end{algorithmic}	
				
				The simplest of temporal operators is the \ex{} operator. During initialization, all states and colors where $\phi$ holds are computed. For each of such states, all predecessors are considered and appropriate message that will cause assumption update is sent.
			
    		\subsection{Exist Until Operator}
				\begin{algorithmic}[1]
				\State $ \textbf{Process variables:} $
				\State $ \ks = (id, f, \mathcal{P}, S, I, \trans{p}, L) $ \Comment{Kripke fragment}
				\State $ \phi = \eu{\phi_1}{\phi_2}  $ \Comment{CTL formula}
				\State $ \as $ \Comment{Initial assumption function}
				\Procedure{Init}{}
					\ForAll {$(state, colSet) $ \textbf{in} $ validStates(\phi_2, \as) $}
						\State $ \as \gets update(\as, state, colSet, \phi) $
						\ForAll { $ (pred, tranCol) $ \textbf{in} $ predecessors(state) $ }
							\State $ \Call{Send}{f(state), (pred, colSet \cap tranCol)} $
						\EndFor
					\EndFor
				\EndProcedure
				\Procedure{Receive}{$colSet, state$}
					\State $ colSet \gets colSet \cap valid(\phi_1, to, \as)$
					\If{$ colSet \neq \emptyset $ \textbf{and} $ colSet \setminus valid(\phi, to, \as) \neq \emptyset $}
						\State $ \as \gets update(\as, to, colSet, \phi) $
						\ForAll {$(pred, tranCol) $ \textbf{in} $ predecessors(to) $ }
							\State $ \Call{Send}{f(pred), (pred, colSat \cap tranCol)} $
						\EndFor
					\EndIf
				\EndProcedure
				\end{algorithmic}	
			
				The \eu{}{} operator is a little more complex, but again fairly simple. The algorithm starts by computing all states and colours where $\phi_2$ is true. Starting from these states, a backpropagation of parameter sets along the reversed transitions is performed. During the computation, the propagated parameter set is updated to reflect the validity of $\phi_1$ and the validity of transitions used along the path. Note that backpropagation is stoped as soon as there is no new information computed ($colSat$ is either empty or equal to already computed assumptions).
			
		    \subsection{All Until Operator}
				\begin{algorithmic}[1]
				\State $ \textbf{Process variables:} $
				\State $ \ks = (id, f, \mathcal{P}, S, I, \trans{p}, L) $ \Comment{Kripke fragment}
				\State $ \phi = \au{\phi_1}{\phi_2}  $ \Comment{CTL formula}
				\State $ T = \trans{p} $ \Comment{Uncovered edges}
				\State $ \as $ \Comment{Initial assumption function}
				\Procedure{Init}{}
					\ForAll {$(state, colSet) $ \textbf{in} $ validStates(\phi_2) $}
						\ForAll { $ (pred, tranCol) $ \textbf{in} $ predecessors(state) $ }
							\State $ \Call{Send}{f(state), (state, pred, \mathcal{P} \cap tranCol)} $
						\EndFor
					\EndFor
				\EndProcedure
				\Procedure{Receive}{$colSet, from, to$}	
					\State $ T \gets T \setminus \{ (to, p, from) | p \in colSet \} $
					\State $ colSet \gets \{ p | p \in colSet \wedge \forall s_2 \in S. (to, p, s_2) \notin T \} $
					\State $ colSet \gets colSet \cap valid(\phi_1, to, \as)$
					\If{$ colSet \neq \emptyset $ \textbf{and} $ colSet \setminus valid(\phi, to, \as) \neq \emptyset $}
						\State $ \as \gets update(\as, to, colSet, \phi) $
						\ForAll {$(pred, tranCol) $ \textbf{in} $ predecessors(to) $ }
							\State $ \Call{Send}{f(pred), (to, pred, colSet \cap tranCol)} $
						\EndFor
					\EndIf
				\EndProcedure
				\end{algorithmic}	
				
				The \au{}{} operator is the most complex one to handle. As opposed to \ex{}{}, which requires at least one valid successor to be true, \au{}{} requires that all successors of the specific node are valid. In order to compute such information, we create a copy of transition relation and call it $T$. 
				
				During the computation, $T$ is modified in such way, so that we can guarantee that if edge is not present in $T$, this edge leads to a state where either $\phi_2$ or \au{\phi_1}{\phi_2} holds. This way, we can guarantee that only appropriate states and colors are marked as valid by our algorithm.
					
    \appendix
    \chapter{First appendix}        % Appendices
    \Blindtext
    \chapter{Another appendix}
    \Blindtext

    \bibliographystyle{ieeetr}  
	\bibliography{bibliography}
    % Bibliography goes here
    % Index goes here (optional)
\end{document}
