\documentclass[12pt,oneside,draft]{fithesis2}
\usepackage[english]{babel}       % Multilingual support
\usepackage[utf8]{inputenc}       % UTF-8 encoding
\usepackage[T1]{fontenc}          % T1 font encoding
\usepackage[                      % A sans serif font that blends well with Palatino
  scaled=0.86
]{berasans}
\usepackage[                      % A tt font if you do not like LM's tt
  scaled=1.03
]{inconsolata}
\usepackage[                      % Clickable links
  plainpages = false,               % We have multiple page numberings
  pdfpagelabels                     % Generate pdf page labels
]{hyperref}
\usepackage{blindtext}            % Lorem ipsum generator

 % Algorithms
\usepackage{algorithm}
%\usepackage[noend]{algpseudocode}
\usepackage{algpseudocode}

\thesislang{en}                   % The language of the thesis
\thesistitle{Parameter Synthesis from Hypotheses Formulable in CTL Logic}       % The title of the thesis
\thesissubtitle{Bachelor Thesis}  % The type of the thesis
\thesisstudent{Samuel Pastva}          % Your name
\thesiswoman{false}                % Your gender
\thesisfaculty{fi}                % Your faculty
\thesisyear{Spring \the\year}     % The academic term of your thesis defense
\thesisadvisor{John Foo, Ph.D.}   % Your advisor


% Macros for definitions
% Assumptions
\newcommand{\as}[1][]{\ensuremath{\mathcal{A}_{#1}}}
\newcommand{\asemt}{\as[\perp]}
\newcommand{\ASphi}{\ensuremath{AS_{\mathcal K}^\phi}}

% Algorithm
\newcommand{\method}[1]{\textnormal{\textsc{#1}}}

%True, false
\newcommand{\true}{\ensuremath{\texttt{tt}}}
\newcommand{\false}{\ensuremath{\texttt{ff}}}

% Kripke
\newcommand{\ks}[1][]{\ensuremath{\mathcal{K}_{#1}}}
\newcommand{\fullks}{\ensuremath{ \ks = (id, f, \params, S, I, \trans{p}, L) }}
\newcommand{\trans}[1]{\stackrel{#1}{\rightarrow}}
\newcommand{\params}{\mathcal{P}}

%Temporal
\newcommand{\eu}[2]{\ensuremath{\mbox{E} #1 \mbox{U} #2 }}
\newcommand{\au}[2]{\ensuremath{\mbox{A} #1 \mbox{U} #2 }}
\newcommand{\ex}[1]{\ensuremath{\mbox{EX} #1}}
\newcommand{\ax}[1]{\ensuremath{\mbox{AX} #1}}
\newcommand{\ef}[1]{\ensuremath{\mbox{EF} #1}}
\newcommand{\af}[1]{\ensuremath{\mbox{AF} #1}}
\newcommand{\eg}[1]{\ensuremath{\mbox{EG} #1}}
\newcommand{\ag}[1]{\ensuremath{\mbox{AG} #1}}

\begin{document}
  \FrontMatter                    % The front matter
    \ThesisTitlePage                % The title page
    \begin{ThesisDeclaration}       % The declaration
      \DeclarationText
      \AdvisorName
    \end{ThesisDeclaration}
    \begin{ThesisThanks}            % The acknowledgements (optional)
      I would like to thank my supervisor\,\dots
    \end{ThesisThanks}
    \begin{ThesisAbstract}          % The abstract
      The aim of the bachelor work is to provide\,\dots
    \end{ThesisAbstract}
    \begin{ThesisKeyWords}          % The keywords
      keyword1, keyword2\,\dots
    \end{ThesisKeyWords}
    \tableofcontents                % The table of contents
%   \listoftables                   % The list of tables (optional)
%   \listoffigures                  % The list of figures (optional)
  
  \MainMatter                     % The main matter
    \chapter{Introduction}          % Chapters
	Lorem Ipsum \cite{testCite}
    \chapter{Algorithm}
    
    	In this chapter, we describe the distributed algorithm that computes the assumption function $\as$. 
    	
    	\section{Distributed Environment}
    	
		In this section, we briefly describe the distributed environment assumed by our algorithm, in order to prevent any possible confusion.
		
		We assume a distributed environment with fixed number of reliable processes connected by reliable, order-preserving channels (The order preservation can be relaxed to some extent). We also assume that each process has a fixed identifier and the set of all process identifiers is equal to the result set of the partition function. Each process can communicate directly (using the function \method{Send}) with any other process (assuming it knows other process's identifier) and all messages that can't be processed directly are stored in a queue until they can be processed.
		
		Several parts of the algorithm do not have explicit termination (they terminate by reaching deadlock - no messages are exchanged between processes). In such cases, suitable termination detection algorithm is employed to detect this deadlock and terminate computation properly. Our implementation uses Safra's algorithm [CITATION] for this purpose, but the related code has been skipped for easier readability.
    	
		We also divide algorithm description into three main parts: Process variables, Initialization and Message handler. First section describes data structures stored in process memory available during whole computation. Initialization section is executed exactly once and no messages can be received until it's finished. Message handler defines what should happen when message is received.  
		
		\section{Algorithm outline}
		
			The main idea of the algorithm is described in REFERENCE and resembles other CTL model checking algorithms.
			
			\begin{algorithmic}[1]
				\Procedure{CheckCTL}{$ \phi, \fullks $}
					\State $ \as \gets \{ (p, s, \alpha, \true) \mid  p \in \params \wedge \alpha \in L(s) \}$ 
					\ForAll { $ i < | \phi | $ }					
						\ForAll { $ \psi $ \textbf{in} $ cl(\phi) $ \textbf{where} $ | \psi | = i $ }
							\State $ \as \gets \Call{CheckFormula}{\psi, \ks, \as } $
						\EndFor
					\EndFor
				\EndProcedure			
			\end{algorithmic} 
			
			The algorithm starts by initializing the assumption function using the labeling function defined in kripke fragment. After that, it traverses the structure of formula, starting from smallest formulas and uses computed results to process more complex formulas. Function \method{CheckFormula} computes all states and colors where formula $\psi$ holds and returns assumption function updated accordingly. This is done using the local information contained in given kripke fragment, assumptions previously computed for smaller formulas and also by communicating with other processes. Note that only assumptions relevant for particular process are computed and returned (each process has information only about it's own state space).
    	
    	\section{Common operations}
    		
    		In this section, we define functions used to simplify the algorithm description. Let us fix a formula $\phi$ and a parametrised kripke fragment $\fullks$ as an input of the algorithm.
			
			Intuitively, function $validStates : cl(\phi) \times \ASphi \rightarrow S \times 2^\mathcal{P} $ computes a set of states and parameters where truth of given formula is assumed. It is also responsible for handling of boolean operators, since these can be computed without any inter-process communication. 
			
			\begin{center}
				$validStates(\phi_1 \wedge \phi_2, \as) = \{ (s, p) \mid \as(s, p, \phi_2) = \true \wedge \as(s, p, \phi_2) = \true \} $
			\end{center}
			
			\begin{center}
				$validStates(\phi_1 \vee \phi_2, \as) = \{ (s, p) \mid \as(s, p, \phi_2) = \true \vee \as(s, p, \phi_2) = \true \} $
			\end{center}
			
			\begin{center}
				$validStates(\neg\phi, \as) = \{ (s, p) \mid \as(s, p, \phi) = \false \} $
			\end{center}
			
			\begin{center}
				$validStates(\true, \as) = \{ (s, p) \mid s \in S \wedge p \in \params \} $
			\end{center}

			\begin{center}
				$validStates(\false, \as) = \emptyset $
			\end{center}
						
			\begin{center}
				$validStates(\phi, \as) = \{ (s, p) \mid \as(s, p, \phi) = \true \} $
			\end{center}

			Another useful function is $validColours : cl(\phi) \times S \times \ASphi \rightarrow 2^\mathcal{P}	$ which returns a set of parameters for which given formula is assumed to be true in given state. 
			
			\begin{center}
				$validColours(\phi, state, \as) = \{ p | (state, p) \in validStates \}$
			\end{center}
			
			Function $predecessors : S \rightarrow S \times 2^\mathcal{P} $ computes set of direct predecessors of given node including the color sets labeling the appropriate transitions.
			
			\begin{center}
				$predecessors(to) = \{ (from, P) \mid P = \{ p \mid from \trans{p} to \} \} $
			\end{center}
			
			Symmetrically, function $successors : S \rightarrow S \times 2^\mathcal{P} $ computes set of direct successors of given node including the color sets labeling the appropriate transitions.

			\begin{center}
				$predecessors(from) = \{ (to, P) \mid P = \{ p \mid from \trans{p} to \} \} $
			\end{center}		

			We also define function $update: \ASphi \times S \times 2^{\params} \times tcl(\phi) \rightarrow \ASphi $ which takes current assumptions, a state, set of parameters and a formula and returns assumptions updated so that for all parameters of the given set, formula holds in given state.
			
			\begin{algorithmic}
				\State $ update(\as, state, colours, \phi): $
				\ForAll { $ p \in colours $}
					\State Set $ \as(state, p, \phi) = \true $
				\EndFor 
			\end{algorithmic}
			
		\section{Temporal Operators}
    
    		In this section, we describe how the \method{CheckFormula} is implemented for each of the temporal operators. Note that all of the following algorithms has implicit termination and therefore needs a proper termination detection algorithm to correctly terminate.
    		
	   		\subsection{Exist Next Operator}
   			   			
				\begin{algorithmic}[1]
				\State $ \textbf{Process variables:} $
				\State $ \ks = (id, f, \mathcal{P}, S, I, \trans{p}, L) $ \Comment{Kripke fragment}
				\State $ \phi = \ex{\phi_1}  $ \Comment{CTL formula}
				\State $ \as $ \Comment{Initial assumption function}
				\Procedure{Init}{}
					\ForAll {$(state, colSet)$ \textbf{in} $ validStates(\phi_1, \as) $}
						\ForAll { $ (pred, tranCol) $ \textbf{in} $ predecessors(state) $ }
							\State $ \Call{Send}{f(state), (pred, colSet \cap tranCol)} $
						\EndFor
					\EndFor
				\EndProcedure
				\Procedure{Receive}{$colSet, to$}
					\State $ \as \gets update(\as, to, colSet, \phi)$
				\EndProcedure
				\end{algorithmic}	
				
				The simplest of temporal operators is the \ex{} operator. During initialization, all states and colors where $\phi$ holds are computed. For each of such states, all predecessors are considered and appropriate message that will cause assumption update is sent.
			
    		\subsection{Exist Until Operator}
				\begin{algorithmic}[1]
				\State $ \textbf{Process variables:} $
				\State $ \ks = (id, f, \mathcal{P}, S, I, \trans{p}, L) $ \Comment{Kripke fragment}
				\State $ \phi = \eu{\phi_1}{\phi_2}  $ \Comment{CTL formula}
				\State $ \as $ \Comment{Initial assumption function}
				\Procedure{Init}{}
					\ForAll {$(state, colSet) $ \textbf{in} $ validStates(\phi_2, \as) $}
						\State $ \as \gets update(\as, state, colSet, \phi) $
						\ForAll { $ (pred, tranCol) $ \textbf{in} $ predecessors(state) $ }
							\State $ \Call{Send}{f(state), (pred, colSet \cap tranCol)} $
						\EndFor
					\EndFor
				\EndProcedure
				\Procedure{Receive}{$colSet, state$}
					\State $ colSet \gets colSet \cap valid(\phi_1, to, \as)$
					\If{$ colSet \neq \emptyset $ \textbf{and} $ colSet \setminus valid(\phi, to, \as) \neq \emptyset $}
						\State $ \as \gets update(\as, to, colSet, \phi) $
						\ForAll {$(pred, tranCol) $ \textbf{in} $ predecessors(to) $ }
							\State $ \Call{Send}{f(pred), (pred, colSat \cap tranCol)} $
						\EndFor
					\EndIf
				\EndProcedure
				\end{algorithmic}	
			
				The \eu{}{} operator is a little more complex, but again fairly simple. The algorithm starts by computing all states and colours where $\phi_2$ is true. Starting from these states, a backpropagation of parameter sets along the reversed transitions is performed. During the computation, the propagated parameter set is updated to reflect the validity of $\phi_1$ and the validity of transitions used along the path. Note that backpropagation is stoped as soon as there is no new information computed ($colSat$ is either empty or equal to already computed assumptions).
			
		    \subsection{All Until Operator}
				\begin{algorithmic}[1]
				\State $ \textbf{Process variables:} $
				\State $ \ks = (id, f, \mathcal{P}, S, I, \trans{p}, L) $ \Comment{Kripke fragment}
				\State $ \phi = \au{\phi_1}{\phi_2}  $ \Comment{CTL formula}
				\State $ T = \trans{p} $ \Comment{Uncovered edges}
				\State $ \as $ \Comment{Initial assumption function}
				\Procedure{Init}{}
					\ForAll {$(state, colSet) $ \textbf{in} $ validStates(\phi_2) $}
						\ForAll { $ (pred, tranCol) $ \textbf{in} $ predecessors(state) $ }
							\State $ \Call{Send}{f(state), (state, pred, \mathcal{P} \cap tranCol)} $
						\EndFor
					\EndFor
				\EndProcedure
				\Procedure{Receive}{$colSet, from, to$}	
					\State $ T \gets T \setminus \{ (to, p, from) | p \in colSet \} $
					\State $ colSet \gets \{ p | p \in colSet \wedge \forall s_2 \in S. (to, p, s_2) \notin T \} $
					\State $ colSet \gets colSet \cap valid(\phi_1, to, \as)$
					\If{$ colSet \neq \emptyset $ \textbf{and} $ colSet \setminus valid(\phi, to, \as) \neq \emptyset $}
						\State $ \as \gets update(\as, to, colSet, \phi) $
						\ForAll {$(pred, tranCol) $ \textbf{in} $ predecessors(to) $ }
							\State $ \Call{Send}{f(pred), (to, pred, colSet \cap tranCol)} $
						\EndFor
					\EndIf
				\EndProcedure
				\end{algorithmic}	
				
				The \au{}{} operator is the most complex one to handle. As opposed to \ex{}{}, which requires at least one valid successor to be true, \au{}{} requires that all successors of the specific node are valid. In order to compute such information, we create a copy of transition relation and call it $T$. 
				
				During the computiation, $T$ is modified in such way, so that we can guarantee that if edge is not present in $T$, this edge leads to a state where either $\phi_2$ or \au{\phi_2}{\phi2} holds.
					
    \appendix
    \chapter{First appendix}        % Appendices
    \Blindtext
    \chapter{Another appendix}
    \Blindtext

    \bibliographystyle{ieeetr}  
	\bibliography{bibliography}
    % Bibliography goes here
    % Index goes here (optional)
\end{document}
